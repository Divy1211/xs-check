# Pseudo Assembly

This is the IR generated by the compiler for further compilation into byte code

## 1. PA Syntax

1. Addressed Instruction ${\tt li} \rightarrow {\tt l : i}$
2. Addressed Instructions ${\tt lis} \rightarrow {\tt li}\ |\ {\tt li\ lis}$
3. Address ${\tt l} \rightarrow 1\ |\ 2\ |\ ...$
4. Instruction ${\tt i} \rightarrow {\tt label}\ |\ {\tt d} \leftarrow {\tt s}\ |\ {\tt d} \leftarrow {\tt s\ op\ s}\ | \ {\tt ret}\ | \ {\tt jmp\ label}\ |\ {\tt ifn\ s\ goto\ l}\ |\ {\tt goto\ l}\ |\ {\tt push\ s}\ |\ {\tt pop\ d}$
5. Operator ${\tt op} \rightarrow {\tt +\ |\ -\ |\ *\ |\ /\ |\ \%\ |\ <\ |\ >\ |\ <=\ |\ >=\ |\ ==\ |\ !=\ |\ \&\&\ |\ \texttt{||}}$
6. Operand ${\tt d, s} \rightarrow {\tt c\ |\ r\ |\ v}$
7. Constant ${\tt c} \rightarrow {\tt LIT}$
8. Register ${\tt r} \rightarrow {\tt r_i}$
9. Identifier ${\tt v} \rightarrow {\tt x\ |\ y\ |\ ...}$

## 2. PA Semantics

- PA assumes the availability of an infinite amount of identifiers (and memory) which are used like registers. Register allocation is deferred until bytecode generation.
- The availability of 32 enumerated 32-bit registers is assumed. The following aliases are used:
  - ${\tt r_{ret} = r_0}$: return value register
  - ${\tt r_{sp} = r_{27}}$: stack pointer
  - ${\tt r_{bp} = r_{28}}$: base pointer
  - ${\tt r_{lp} = r_{29}}$: link pointer
  - ${\tt r_{xp} = r_{30}}$: exception pointer
- The value of ${\tt r_{31}}$ is always $0$
- A stack is maintained to support procedures.
- The ${\tt goto}$ instruction simply jumps to an address, whereas the ${\tt jmp}$ instruction jumps to a label and writes the current address to ${\tt r_{lp}}$
- ${\tt ret}$ jumps to the address in ${\tt r_{lp}} + 1$